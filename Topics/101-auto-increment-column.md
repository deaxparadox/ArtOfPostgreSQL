# Using PostgreSQL SERIAL to Create Auto-increment Column

# Introduction to the PostgreSQL SERIAL pseudo-type

In PostgreSQL, a sequence kind of database object that generates a sequence of integers. A sequence is often used as the primary key column in a table.

When creating a new table, the sequence can be created through the `SERIAL` pseudo-type as follows:

```sql
CREATE TABLE table_name(
    id SERIAL
);
```

By assigning the `SERIAL` pseudo-type to `id` column, PostgreSQL performs the following:

- First, create a sequence object and set the next value generated by the sequence as the default value for the column.
- Second, add a `NOT NULL` constraint to the `id` column because a sequence always generates an integer, which is a non-null value.
- Third, assign the owner of the sequence to the `id` column; as a result, the sequence object is deleted when the `id` column or table is dropped

Behind the scenes, the following statement:

```sql
CREATE TABLE table_name(
    id SERIAL
);
```

is equivalent to the following statements:

```sql
CREATE SEQUENCE table_name_id_seq;

CREATE TABLE table_name (
    id integer NOT NULL DEFAULT nextval('table_name_id_seq')
);

ALTER SEQUENCE table_name_id_seq
OWNED BY table_name.id;
```

----------

PostgreSQL provides three serial pseudo-types `SMALLSERIAL`, `SERIAL`, and `BIGSERIAL` with the following characteristics:

<table><thead><tr><td><strong>Name</strong></td><td><strong>Storage Size</strong></td><td><strong>Range</strong></td></tr></thead><tbody><tr><td>SMALLSERIAL</td><td>2 bytes</td><td>1 to 32,767</td></tr><tr><td>SERIAL</td><td>4 bytes</td><td>1 to 2,147,483,647</td></tr><tr><td>BIGSERIAL</td><td>8 bytes</td><td>1 to 9,223,372,036,854,775,807</td></tr></tbody></table>



----------

### PostgreSQL SERIAL example

It is important to note that the `SERIAL` does not implicitly create an index on the column or make the column as the primary key column. However, this can be done easily by specifying the `PRIMARY KEY` constraint for the `SERIAL` column.

The following statement creates the `fruits` table with the `id` column as the `SERIAL` column:

```sql
CREATE TABLE fruits(
   id SERIAL PRIMARY KEY,
   name VARCHAR NOT NULL
);
```

To assign the default value for a serial column when you insert row into the table, you ignore the column name or use the `DEFAULT` keyword in the `INSERT` statement.

See the following example:

```sql
INSERT INTO fruits(name) 
VALUES('Orange');
```

Or

```sql
INSERT INTO fruits(id,name) 
VALUES(DEFAULT,'Apple');
```

PostgreSQL inserted two rows into the `fruits` table with the values for the id column are 1 and 2.

```sql
SELECT * FROM fruits;
```

```sql
 id |  name
----+--------
  1 | Apple
  2 | Orange
(2 rows)
```

To get the sequence name of a `SERIAL` column in a table, you use the `pg_get_serial_sequence()` function as follows:

```sql
pg_get_serial_sequence('table_name','column_name')
```

You can pass a sequence name to the `currval()` function to get he recent value generated by the sequence. For example, the following statement returns the recent values generated by the `furits_id_seq` object:

```sql
SELECT currval(pg_get_serial_sequence('fruits', 'id'));
```

```sql
currval
---------
2
(1 row)
```

If you want to get the value generated by the sequence when you insert a new row into the table, you use the `RETURNING id` clause in the `INSERT` statement.

The following statement inserts a new row into the `fruits` table and returns the value generated for the id column.

```sql
INSERT INTO fruits(name) 
VALUES('Banana')
RETURNING id;
```

```sql
id
----
3
(1 row)
```

The sequence generator operation is not transaction-safe. It means that if two concurrent database connections attempt to get the next value from a sequence, each client will get a different value. If one client rolls back the transaction, the sequence number of that client will be unused, creating a gap in the sequence.

